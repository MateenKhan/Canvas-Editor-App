import { Shape, Point } from '../types';
import { getShapeBounds } from './shapes';

export function generateGCode(shapes: Shape[], marginMM: number): string {
  let gcode = '';
  
  // Header
  gcode += '; G-code generated by Canvas Editor\n';
  gcode += '; Date: ' + new Date().toISOString() + '\n';
  gcode += `; Margin: ${marginMM}mm\n`;
  gcode += '; Total shapes: ' + shapes.length + '\n';
  gcode += '\n';
  
  // Initialize
  gcode += 'G21 ; Set units to millimeters\n';
  gcode += 'G90 ; Absolute positioning\n';
  gcode += 'G0 Z5 ; Lift tool\n';
  gcode += 'M3 S1000 ; Start spindle/laser\n';
  gcode += '\n';

  // Find overall bounds
  let minX = Infinity;
  let minY = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;

  shapes.forEach(shape => {
    const bounds = getShapeBounds(shape);
    minX = Math.min(minX, bounds.x);
    minY = Math.min(minY, bounds.y);
    maxX = Math.max(maxX, bounds.x + bounds.width);
    maxY = Math.max(maxY, bounds.y + bounds.height);
  });

  // Convert pixels to mm (assuming 96 DPI, 1 inch = 25.4mm)
  const pixelsToMM = (pixels: number) => (pixels / 96) * 25.4;

  // Add margin offset
  const offsetX = marginMM;
  const offsetY = marginMM;

  // Process each shape
  shapes.forEach((shape, index) => {
    gcode += `\n; Shape ${index + 1}: ${shape.type}\n`;
    
    const points = getShapePoints(shape);
    
    if (points.length === 0) return;

    // Move to start position (tool up)
    const startX = pixelsToMM(points[0].x - minX) + offsetX;
    const startY = pixelsToMM(points[0].y - minY) + offsetY;
    gcode += `G0 X${startX.toFixed(3)} Y${startY.toFixed(3)} ; Move to start\n`;
    gcode += 'G1 Z0 F300 ; Lower tool\n';

    // Draw the shape
    for (let i = 1; i < points.length; i++) {
      const x = pixelsToMM(points[i].x - minX) + offsetX;
      const y = pixelsToMM(points[i].y - minY) + offsetY;
      gcode += `G1 X${x.toFixed(3)} Y${y.toFixed(3)} F1000\n`;
    }

    // Lift tool
    gcode += 'G0 Z5 ; Lift tool\n';
  });

  // Footer
  gcode += '\n; End of program\n';
  gcode += 'M5 ; Stop spindle/laser\n';
  gcode += 'G0 Z10 ; Raise tool\n';
  gcode += 'G0 X0 Y0 ; Return to origin\n';
  gcode += 'M30 ; Program end\n';

  return gcode;
}

function getShapePoints(shape: Shape): Point[] {
  const points: Point[] = [];
  
  switch (shape.type) {
    case 'freeLine':
      return shape.points;
      
    case 'straightLine':
      if (shape.startPoint && shape.endPoint) {
        return [shape.startPoint, shape.endPoint];
      }
      return [];
      
    case 'rectangle':
      if (shape.x !== undefined && shape.y !== undefined && shape.width && shape.height) {
        return [
          { x: shape.x, y: shape.y },
          { x: shape.x + shape.width, y: shape.y },
          { x: shape.x + shape.width, y: shape.y + shape.height },
          { x: shape.x, y: shape.y + shape.height },
          { x: shape.x, y: shape.y }, // Close the rectangle
        ];
      }
      return [];
      
    case 'circle':
    case 'ellipse':
      if (shape.x !== undefined && shape.y !== undefined && shape.width && shape.height) {
        const centerX = shape.x + shape.width / 2;
        const centerY = shape.y + shape.height / 2;
        const radiusX = shape.width / 2;
        const radiusY = shape.height / 2;
        const numPoints = 64;
        
        for (let i = 0; i <= numPoints; i++) {
          const angle = (i / numPoints) * Math.PI * 2;
          points.push({
            x: centerX + Math.cos(angle) * radiusX,
            y: centerY + Math.sin(angle) * radiusY,
          });
        }
      }
      return points;
      
    case 'triangle':
      if (shape.x !== undefined && shape.y !== undefined && shape.width && shape.height) {
        return [
          { x: shape.x + shape.width / 2, y: shape.y },
          { x: shape.x + shape.width, y: shape.y + shape.height },
          { x: shape.x, y: shape.y + shape.height },
          { x: shape.x + shape.width / 2, y: shape.y }, // Close
        ];
      }
      return [];
      
    case 'heart':
      if (shape.x !== undefined && shape.y !== undefined && shape.width && shape.height) {
        const numPoints = 64;
        for (let i = 0; i <= numPoints; i++) {
          const t = (i / numPoints) * Math.PI * 2;
          const x = shape.x + shape.width / 2 + (shape.width / 2) * (16 * Math.pow(Math.sin(t), 3)) / 16;
          const y = shape.y + shape.height / 2 - (shape.height / 2) * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 13;
          points.push({ x, y });
        }
      }
      return points;
      
    case 'star':
      if (shape.x !== undefined && shape.y !== undefined && shape.width && shape.height) {
        const centerX = shape.x + shape.width / 2;
        const centerY = shape.y + shape.height / 2;
        const outerRadius = Math.min(shape.width, shape.height) / 2;
        const innerRadius = outerRadius * 0.4;
        const numPoints = 5;
        
        for (let i = 0; i <= numPoints * 2; i++) {
          const radius = i % 2 === 0 ? outerRadius : innerRadius;
          const angle = (Math.PI * i) / numPoints - Math.PI / 2;
          points.push({
            x: centerX + Math.cos(angle) * radius,
            y: centerY + Math.sin(angle) * radius,
          });
        }
      }
      return points;
      
    case 'pentagon':
      return getPolygonPoints(shape, 5);
      
    case 'hexagon':
      return getPolygonPoints(shape, 6);
      
    case 'arrow':
      if (shape.startPoint && shape.endPoint) {
        const { x: x1, y: y1 } = shape.startPoint;
        const { x: x2, y: y2 } = shape.endPoint;
        const angle = Math.atan2(y2 - y1, x2 - x1);
        const headLength = 20;
        
        return [
          { x: x1, y: y1 },
          { x: x2, y: y2 },
          { x: x2 - headLength * Math.cos(angle - Math.PI / 6), y: y2 - headLength * Math.sin(angle - Math.PI / 6) },
          { x: x2, y: y2 },
          { x: x2 - headLength * Math.cos(angle + Math.PI / 6), y: y2 - headLength * Math.sin(angle + Math.PI / 6) },
        ];
      }
      return [];
  }
  
  return [];
}

function getPolygonPoints(shape: Shape, sides: number): Point[] {
  if (shape.x === undefined || shape.y === undefined || !shape.width || !shape.height) {
    return [];
  }
  
  const points: Point[] = [];
  const centerX = shape.x + shape.width / 2;
  const centerY = shape.y + shape.height / 2;
  const radius = Math.min(shape.width, shape.height) / 2;
  
  for (let i = 0; i <= sides; i++) {
    const angle = (Math.PI * 2 * i) / sides - Math.PI / 2;
    points.push({
      x: centerX + Math.cos(angle) * radius,
      y: centerY + Math.sin(angle) * radius,
    });
  }
  
  return points;
}
